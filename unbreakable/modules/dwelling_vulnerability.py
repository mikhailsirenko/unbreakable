import pandas as pd
from typing import Dict, Literal

ROOF_SCORES: Dict[str, float] = {
    "Concrete": 0.2,
    "Finished – Concrete": 0.2,
    "Finished – Metal": 0.4,
    "Finished – Tile": 0.4,  # TODO: Confirm this value
    "Tile": 0.5,
    "Shingle (asphalt)": 0.5,
    "Shingle (other)": 0.5,
    "Finished – Asbestos": 0.6,
    "Shingle (wood)": 0.6,
    "Finished – Wood": 0.6,  # TODO: Confirm this value
    "Sheet metal (galvanize, galvalume)": 0.65,
    "Makeshift/thatched": 0.8,
    "Natural – Thatch/palm leaf": 0.8,
    "Other": 0.8,
}

WALL_SCORES: Dict[str, float] = {
    "Concrete/Concrete blocks": 0.2,
    "Concrete/Concrete Blocks": 0.2,
    "Finished – Cement blocks": 0.3,
    "Brick/Blocks": 0.35,
    "Wood & Concrete": 0.4,
    "Finished – Stone with lime/cement": 0.45,
    "Finished – GRC/Gypsum/Asbestos": 0.5,
    "Wood/Timber": 0.6,
    "Finished – Wood planks/shingles": 0.6,  # TODO: Confirm this value
    "Natural – Other": 0.6,
    "Plywood": 0.7,
    "Rudimentary – Plywood": 0.7,
    "Rudimentary – Other": 0.7,  # TODO: Confirm this value
    "Rudimentary – Uncovered adobe": 0.75,  # TODO: Confirm this value
    "Natural – Cane/palm/trunks": 0.75,  # TODO: Confirm this value
    "Makeshift": 0.8,
    "Makeshift": 0.8,
    "Other": 0.8,
}

FLOOR_SCORES: Dict[str, float] = {
    "Finished – Cement/red bricks": 0.2,
    "Finished – Parquet or polished wood": 0.4,
    "Rudimentary – Wood planks": 0.5,
    "Natural – Earth/sand": 0.7,
    "Other": 0.6,
}

DISASTER_MULTIPLIERS = {
    "hurricane": {"roof": 0.6, "walls": 0.3, "floor": 0.1},
    "earthquake": {"roof": 0.2, "walls": 0.6, "floor": 0.2},
    "flood": {"roof": 0.2, "walls": 0.4, "floor": 0.4},
}


def calculate_dwelling_vulnerability(
    households: pd.DataFrame, disaster_type: str
) -> pd.DataFrame:
    """
    Calculate dwelling vulnerability based on roof and wall types for a given disaster type.
    If floor data is available, it will be included in the calculation.

    Args:
        households (pd.DataFrame): Households DataFrame with 'walls' and 'roof' columns. 'floor' column is optional.
        disaster_type (str): Type of disaster ('hurricane', 'earthquake', or 'flood').

    Returns:
        pd.DataFrame: DataFrame with added vulnerability columns.

    Raises:
        ValueError: If an unsupported disaster type is provided or if there are missing scores for wall or roof types.
    """
    # ! ASSUMPTION
    # If material type is not found in the scores, it is assumed to be 'Other'
    # Note that 'Other' is the most vulnerable material type

    # Calculate vulnerability scores for walls and roofs
    households["v_walls"] = (
        households["walls"].map(WALL_SCORES).fillna(WALL_SCORES["Other"])
    )
    households["v_roof"] = (
        households["roof"].map(ROOF_SCORES).fillna(ROOF_SCORES["Other"])
    )

    # Check if floor data is available
    floor_data_available = "floor" in households.columns

    if floor_data_available:
        households["v_floor"] = (
            households["floor"].map(FLOOR_SCORES).fillna(FLOOR_SCORES["Other"])
        )

    # Check for any missing scores
    missing_wall_types = households[households["v_walls"].isnull()]["walls"].unique()
    missing_roof_types = households[households["v_roof"].isnull()]["roof"].unique()

    missing_types_message = (
        f"Missing scores for wall types: {missing_wall_types} "
        f"and roof types: {missing_roof_types}"
    )

    if floor_data_available:
        missing_floor_types = households[households["v_floor"].isnull()][
            "floor"
        ].unique()
        missing_types_message += f" and floor types: {missing_floor_types}"

    if (
        missing_wall_types.size > 0
        or missing_roof_types.size > 0
        or (floor_data_available and missing_floor_types.size > 0)
    ):
        raise ValueError(missing_types_message)

    # Get multipliers for the given disaster type
    try:
        if "+" in disaster_type:
            disaster_types = disaster_type.split("+")
            multipliers = {
                key: max(
                    DISASTER_MULTIPLIERS[disaster_type][key]
                    for disaster_type in disaster_types
                )
                for key in ["walls", "roof", "floor"]
            }
        else:
            multipliers = DISASTER_MULTIPLIERS[disaster_type]
    except KeyError:
        raise ValueError(f"Disaster type '{disaster_type}' not supported")

    # Calculate initial vulnerability
    if floor_data_available:
        households["v_init"] = (
            households["v_walls"] * multipliers["walls"]
            + households["v_roof"] * multipliers["roof"]
            + households["v_floor"] * multipliers["floor"]
        )
    else:
        # Adjust the calculation if floor data is not available
        total_weight = multipliers["walls"] + multipliers["roof"]
        households["v_init"] = (
            households["v_walls"] * multipliers["walls"]
            + households["v_roof"] * multipliers["roof"]
        ) / total_weight

    return households
